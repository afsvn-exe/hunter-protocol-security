# Day 1: Stack Fundamentals

> *"The stack is predictable. That predictability is both its utility and its vulnerability."*

---

## Core Concept: The Stack

The **stack** is a region of memory used for:
- Function call management (return addresses, saved registers)
- Local variables
- Temporary storage

It operates as a Last-In-First-Out (LIFO) structure. On x86-64 Linux, the stack **grows downward** — toward lower memory addresses.

---

## The Two Key Registers

| Register | Name | Purpose |
|----------|------|---------|
| **RSP** | Stack Pointer | Points to the *top* of the stack (lowest address in use) |
| **RBP** | Base Pointer / Frame Pointer | Points to the *base* of the current stack frame |

RBP serves as a stable reference point within a function. Local variables are accessed relative to RBP.

---

## What Happens When a Function is Called

### Step 1: The `call` Instruction

When `main()` executes `call examine_stack`:

1. The address of the *next instruction* in main (the return address) is pushed onto the stack
2. RIP (instruction pointer) jumps to `examine_stack`

```
Before call:
    RSP → [top of stack]

After call:
    RSP → [return address]    ← Pushed automatically by `call`
```

### Step 2: Function Prologue

The first instructions of `examine_stack` (generated by the compiler):

```asm
push rbp        ; Save caller's frame pointer
mov rbp, rsp    ; Establish new frame pointer
sub rsp, N      ; Allocate space for local variables
```

After prologue:
```
    Higher addresses
    ┌──────────────────┐
    │  return address  │  ← Pushed by `call` instruction
    ├──────────────────┤
    │    saved RBP     │  ← Pushed by `push rbp`
    ├──────────────────┤
    │                  │
    │  local variables │  ← Space created by `sub rsp, N`
    │                  │
    └──────────────────┘
    Lower addresses (RSP points here)
```

### Step 3: Function Epilogue (on return)

```asm
leave           ; Equivalent to: mov rsp, rbp; pop rbp
ret             ; Pop return address into RIP, jump there
```

---

## Stack Frame Layout (x86-64 Linux)

For a function with local variables:

```
    Higher addresses (bottom of stack conceptually)
    ┌────────────────────────┐
    │    return address      │  ← RBP + 8
    ├────────────────────────┤
    │      saved RBP         │  ← RBP points here (offset 0)
    ├────────────────────────┤
    │   alignment padding    │  ← May exist for 16-byte alignment
    ├────────────────────────┤
    │                        │
    │    local variables     │  ← Negative offsets from RBP
    │    (arrays, structs)   │
    │                        │
    ├────────────────────────┤
    │   more local vars      │
    └────────────────────────┘
    Lower addresses (RSP, top of stack)
```

**Critical insight:** The compiler can arrange local variables in any order. You cannot assume a variable declared first is at a higher or lower address.

---

## Today's Empirical Observations

From `stack_examine.c` with:
- `char buffer[64]`
- `int x = 0xDEADBEEF`
- `int y = 0xCAFEBABE`

### Observed Addresses

| Item | Address | Offset from buffer |
|------|---------|-------------------|
| buffer[0] | 0x7fffffffdc80 | 0 |
| x | 0x7fffffffdc7c | -4 (below buffer) |
| y | 0x7fffffffdc78 | -8 (below buffer) |
| saved RBP | 0x7fffffffdcd0 | +80 |
| return address | 0x7fffffffdcd8 | +88 |

### Memory Dump Annotated

```
Address          Contents                    Meaning
─────────────────────────────────────────────────────────────
0x7fffffffdc78   0xCAFEBABE                  y (4 bytes)
0x7fffffffdc7c   0xDEADBEEF                  x (4 bytes)
0x7fffffffdc80   0x4141414141414141          buffer[0-7]
0x7fffffffdc88   0x4141414141414141          buffer[8-15]
0x7fffffffdc90   0x4141414141414141          buffer[16-23]
0x7fffffffdc98   0x4141414141414141          buffer[24-31]
0x7fffffffdca0   0x4141414141414141          buffer[32-39]
0x7fffffffdca8   0x4141414141414141          buffer[40-47]
0x7fffffffdcb0   0x4141414141414141          buffer[48-55]
0x7fffffffdcb8   0x4141414141414141          buffer[56-63]
0x7fffffffdcc0   0x0000000000000000          padding (8 bytes)
0x7fffffffdcc8   0x00000040f7ffe2f0          padding (8 bytes)
0x7fffffffdcd0   0x00007fffffffdce0          saved RBP
0x7fffffffdcd8   0x0000000000400558          RETURN ADDRESS ← Target
```

### Key Measurements

| Distance | Bytes |
|----------|-------|
| buffer to end of buffer | 64 |
| buffer to saved RBP | 80 |
| buffer to return address | **88** |

---

## The Overflow Path

When writing to `buffer`, data flows toward **higher addresses**:

```
Write direction →

buffer[0] → buffer[63] → padding → saved RBP → RETURN ADDRESS
   ↑                                               ↑
  Start                                     Attacker's target
  here                                      (offset +88)
```

If an unbounded copy (like `strcpy`) writes more than 64 bytes:
- Bytes 0-63: Fill buffer (intended)
- Bytes 64-79: Overwrite padding (corruption begins)
- Bytes 80-87: Overwrite saved RBP (breaks caller's frame)
- Bytes 88-95: **Overwrite return address** (control flow hijack)

---

## Why x and y Were Not Overwritten

The compiler placed `x` and `y` at *lower* addresses than `buffer`:

```
    Lower addresses
    ┌─────────────┐
    │      y      │  ← 0x7fffffffdc78
    ├─────────────┤
    │      x      │  ← 0x7fffffffdc7c
    ├─────────────┤
    │  buffer[0]  │  ← 0x7fffffffdc80  (overflow starts here)
    │     ...     │           ↓
    │  buffer[63] │           ↓ (overflow direction: toward higher addresses)
    ├─────────────┤           ↓
    │   padding   │           ↓
    ├─────────────┤           ↓
    │  saved RBP  │           ↓
    ├─────────────┤           ↓
    │  ret addr   │  ← Overflow destination
    └─────────────┘
    Higher addresses
```

An overflow from `buffer` goes *up* in memory, missing `x` and `y` entirely. If the compiler had placed them above `buffer`, they would be corrupted first.

**Lesson:** You cannot predict what gets corrupted without examining the actual layout. The compiler makes its own decisions.

---

## Alignment Padding

x86-64 System V ABI requires the stack to be **16-byte aligned** at function call boundaries. The compiler inserts padding to satisfy this.

In our case: 16 bytes of padding existed between `buffer[63]` and saved RBP.

This padding is "dead space" from the program's perspective, but an attacker's overflow writes through it on the way to the return address.

---

## Reading RBP from C

GCC extension to access CPU registers:

```c
register void *rbp asm("rbp");
printf("RBP value: %p\n", rbp);           // Print RBP's value
printf("Return addr at: %p\n", rbp + 8);  // Return address location
```

- `register` — variable lives in a CPU register
- `asm("rbp")` — bind to the RBP register specifically
- `rbp` contains an address (the saved RBP location)
- `rbp + 8` is the return address location (void* arithmetic in GCC is byte-level)

---

## GDB Commands Used

| Command | Purpose |
|---------|---------|
| `break examine_stack` | Set breakpoint at function entry |
| `break 25` | Set breakpoint at specific line |
| `run` | Start program |
| `next` | Execute one source line |
| `continue` | Run until next breakpoint |
| `info registers rbp rsp` | Show register values |
| `x/20xg $rsp` | Examine 20 quadwords (8 bytes each) in hex, starting at RSP |
| `x/20xg 0x7fffffffdc80` | Examine memory at specific address |
| `list examine_stack` | Show source code around function |
| `list 14,25` | Show lines 14-25 |

### Memory Examine Format: `x/NFU`

- **N** — count (how many units)
- **F** — format (x=hex, d=decimal, s=string, i=instruction)
- **U** — unit size (b=byte, h=halfword/2 bytes, w=word/4 bytes, g=giant/8 bytes)

Example: `x/20xg` = 20 units, hex format, giant (8-byte) units

---

## Security Implications

### Why Stack Predictability Matters to Attackers

1. **Known offsets:** Return address is at a predictable offset from local buffers
2. **No randomization (without ASLR):** Addresses are consistent across runs
3. **Control flow target:** Overwriting return address redirects execution

### What We Disabled

`-fno-stack-protector` disables the **stack canary** — a defense mechanism that places a random value between local variables and the saved RBP. If an overflow corrupts it, the program detects the attack and aborts.

In production code, the canary would be at offset +64 (right after buffer), catching any overflow before it reaches the return address.

---

## Connection to CWE-120

**CWE-120: Buffer Copy without Checking Size of Input**

The vulnerability class we're building toward. Now you understand:
- What gets overwritten (saved RBP at +80, return address at +88)
- Why it's exploitable (attacker controls where execution goes)
- What the attacker needs to know (buffer address, offset to return address)

Tomorrow: How strings are stored, and what happens when they lack NUL terminators.

---

## Key Takeaways

1. The stack grows **downward** (toward lower addresses)
2. Return address is pushed by `call`, saved RBP by function prologue
3. Local variable layout is **compiler-determined**, not declaration-ordered
4. Overflow direction is toward **higher addresses** (toward return address)
5. **88 bytes** from buffer start to return address (in today's example)
6. Alignment padding exists but doesn't protect anything
7. Understanding the exact layout requires empirical examination

---

## Vocabulary

| Term | Definition |
|------|------------|
| **Stack frame** | The region of stack memory belonging to one function invocation |
| **Prologue** | Instructions at function entry that set up the stack frame |
| **Epilogue** | Instructions at function exit that tear down the stack frame |
| **Saved RBP** | The caller's frame pointer, preserved on the stack |
| **Return address** | Address of instruction to execute after function returns |
| **Stack canary** | Random value placed on stack to detect buffer overflows |
| **Alignment padding** | Unused bytes inserted to satisfy alignment requirements |

---

*Day 1 complete. The stack is no longer abstract.*
